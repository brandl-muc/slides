\documentclass{beamer}
 \setbeamercovered{transparent}
 \usetheme{Madrid}
 \usecolortheme{lily}
 \geometry{paperwidth=160mm,paperheight=90mm}
\usepackage{listings}
\usepackage{accsupp}
\newcommand*{\noaccsupp}[1]{\BeginAccSupp{ActualText={}}#1\EndAccSupp{}}

\definecolor{ForestGreen}{RGB}{60, 160, 49}

\lstdefinestyle{Common}
{
    numbers=left,
    numbersep=1em,
    numberstyle=\tiny\color{red}\noaccsupp,
    frame=single,
    framesep=\fboxsep,
    framerule=\fboxrule,
    rulecolor=\color{red},
    xleftmargin=\dimexpr\fboxsep+\fboxrule\relax,
    xrightmargin=\dimexpr\fboxsep+\fboxrule\relax,
    breaklines=true,
    tabsize=2,
    columns=flexible,
}

\lstdefinestyle{C++}
{
	style=Common,
    language={C++},
    basicstyle=\ttfamily,
    keywordstyle=\color{blue}\ttfamily,
    stringstyle=\color{red}\ttfamily,
    commentstyle=\color{ForestGreen}\ttfamily,
    morecomment=[l][\color{gray}]{\#},
    backgroundcolor=\color{orange!10},
}

\lstdefinestyle{TinyC++}
{
	style=Common,
    language={C++},
    basicstyle=\ttfamily\tiny,
    keywordstyle=\color{blue}\ttfamily,
    stringstyle=\color{red}\ttfamily,
    commentstyle=\color{ForestGreen}\ttfamily,
    morecomment=[l][\color{gray}]{\#},
    backgroundcolor=\color{orange!10},
}


\lstnewenvironment{C++}{\lstset{style=C++}}{}
\lstnewenvironment{TinyC++}{\lstset{style=TinyC++}}{}

\title{An application for private inheritance?}
\subtitle{Lightning Talk for MUC++}	
\author{Matth\"aus Brandl}
\date{2018-05-17}
\subject{Computer Science}

\def\code#1{\texttt{#1}}
\def\cite#1{\textit{\textcolor{blue}{#1}}}
\def\titleinframe#1{{\usebeamercolor[fg]{structure} #1}}
\def\link#1#2{\href{#1}{\usebeamercolor[fg]{structure} \underline{#2}}}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frame{\titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Wait, what?}
\framesubtitle{What is private inheritance}

\begin{C++}
class Derived : private Base
{};
\end{C++}

\begin{itemize}
\item all public and protected members of \code{Base} are accessible as private members of the derived class
\item private members of the base are never accessible unless friended
\item instances of \code{Derived} cannot be cast to \code{Base} as this relationship is inaccessible outside of \code{Derived}
\end{itemize}

Consequently this models HAS-A instead of IS-A.\\
But \cite{favor composition over inheritance} is also valid here, so HAS-A is better modelled by using a member variable because this causes less coupling. Also one is less likely to violate the Liskov Substitution Principle.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Exceptions to the rule}
%\framesubtitle{To every rule there is an exception}
Private inheritance should be used if one does not want to model IS-A but
\begin{itemize}
\item needs to override a virtual function
\item needs access to a protected member
\item needs to create an object before / destroy it after another base
\item needs to share a virtual base or needs to control the construction of a virtual base
\item wants to make use of the Empty Base Optimization, e.g. with policy-based design
\end{itemize}

Also see the \href{https://isocpp.org/wiki/faq/private-inheritance}{\beamergotobutton{C++ FAQ}} or \href{https://en.cppreference.com/w/cpp/language/derived_class%23Private_inheritance}{\beamergotobutton{cppreference.com}}.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{The problem}
%\framesubtitle{Subtitle}
Suppose the following C API:

\begin{C++}
typedef struct
{
    /* raw owning pointer, it's C after all */
    char const * name;

    /* more variables that need resources ... */
} Widget;

int createWidget(Widget const ** widget);

void freeWidget(Widget const * widget);
\end{C++}

Your job now is to implement this API using C++.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{The C-ish approach}
\framesubtitle{Tedious but effective}
\begin{columns}
\begin{column}{0.45\textwidth}
\begin{TinyC++}
int createWidget(Widget const ** const widget)
{
	auto const newWidget = (Widget *) malloc(sizeof(Widget));
	if (!newWidget)
	{
		return 0;
	}
    
	auto const name = std::string(/* ... */);
	if (name.emtpty())
	{
		free(newWidget);
		return 0;
	}
	newWidget->name = strdup(name.c_str());
    
	/* ... */
    
	*widget = newWidget;
	return 1;
}
\end{TinyC++}
\end{column}
\begin{column}{0.45\textwidth}
\begin{TinyC++}
void freeWidget(Widget const * const widget)
{
	if (widget->name)
	{
		free(widget->name);
	}
    
	/* ... */
    
	free(widget);
}
\end{TinyC++}
\end{column}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{The C-ish approach}
%\framesubtitle{Tedious but effective}
\begin{columns}[T]
\begin{column}{0.45\textwidth}
	\titleinframe{Advantages:}
	\begin{itemize}
	\item straightforward to implement
	\item easy to understand
	\item low complexity
	\end{itemize}
\end{column}
\begin{column}{0.45\textwidth}
	\titleinframe{Disadvantages:}
	\begin{itemize}
	\item manual ressource management
	\item error prone
	\item hard to get right
	\item \code{Widget} members are not zero initialized
	\item manual ressource management!
	\end{itemize}
\end{column}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Automating the ressource management}
\framesubtitle{That's why we like C++}
\begin{columns}
\begin{column}{0.45\textwidth}
\begin{TinyC++}
class WidgetWrapper : public Widget
{
public:
	explicit WidgetWrapper()
        : Widget()	// Default initialization!
	{}

	void setName(std::string value)
	{
		m_name = std::move(value);
		name = m_name.c_str();
	}

	// More setters...
	
private:
	std::string m_name;
};
\end{TinyC++}
\end{column}
\begin{column}{0.45\textwidth}
\begin{TinyC++}
int createWidget(Widget const ** const widget)
try
{
	auto newWidget = std::make_unique<WidgetWrapper>();
    
	auto name = std::string(/* ... */);
	if (name.empty())
	{
		return 0;
	}
	newWidget->setName(std::move(name));

	// More setters
    
	*widget = newWidget.release();
	return 1;
}
catch (std::bad_alloc const &)
{
	return 0;
}

void freeWidget(Widget const * const widget)
{
	delete static_cast<WidgetWrapper const *>(widget);
}
\end{TinyC++}
\end{column}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Automating the ressource management}
%\framesubtitle{That's why we like C++}
\begin{columns}[T]
\begin{column}{0.45\textwidth}
	\titleinframe{Advantages:}
	
	\medskip
	Easier usage:	
	\begin{itemize}
	\item automated resource management
	\item \code{Widget} members are default initialized
	\item easier \code{createWidget()} implementation
	\item easier \code{freeWidget()} implementation
	\item encapsulated "conversion" to C types
	\end{itemize}
\end{column}
\begin{column}{0.45\textwidth}
	\titleinframe{Disadvantages:}
	
	\medskip
	Potential for resource leaks:
	\begin{itemize}
	\item \code{static\_cast} can be forgotten during deletion
	\item implementer can still access \code{Widget} members and , e.g., assign raw owning pointers
	\end{itemize}

\end{column}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Enter private inheritance}
\framesubtitle{Making \code{Wrapper} members inaccessible}
\begin{columns}
\begin{column}{0.45\textwidth}
\begin{TinyC++}
class WidgetWrapper : private Widget // private!
{
	// As before
public:	
	Widget const * toWidget() const
	{
		return static_cast<Widget const *>(this);
	}
	
	static void deleteWidget(Widget const * const widget)
	{
		delete static_cast<WidgetWrapper const *>(widget);
	}
};
\end{TinyC++}
\end{column}
\begin{column}{0.45\textwidth}
\begin{TinyC++}
int createWidget(Widget const ** const widget)
try
{
	// As before
    
	*widget = newWidget->toWidget();
	newWidget.release();
	return 1;
}
catch (std::bad_alloc const &)
{
	return 0;
}

void freeWidget(Widget const * const widget)
{
	WidgetWrapper::deleteWidget(widget);
}
\end{TinyC++}
\end{column}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Enter private inheritance}
%\framesubtitle{Making \code{Wrapper} members inaccessible}
\begin{columns}[T]
\begin{column}{0.45\textwidth}
	\titleinframe{Advantages:}
	
	\medskip
	\begin{itemize}
	\item Easy to use right, hard to use wrong
	\item \code{Widget} members not public anymore in \code{WidgetWrapper} context
	\end{itemize}
\end{column}
\begin{column}{0.45\textwidth}
	\titleinframe{Disadvantages:}
	
	\medskip
	\begin{itemize}
	\item deleting a \code{Widget} directly still possible
	\item increased complexity, two additional functions necessary
	\item uses private inheritance for an IS-A relationship
	\end{itemize}
\end{column}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Alternatives?}
	\begin{itemize}
	\item Do not introduce private inheritance and trust in that no one will use the \code{Widget} wrongly
	\item Use aggregation and pass the pointer to the member to the client\\
	But now shared state between \code{createWidget()} and \code{freeWidget()} is necessary to find the correct \code{WidgetWrapper} instance for the given \code{Widget} pointer
	\end{itemize}
	
	\bigskip
	Please share your opinion and ideas
	
	\bigskip
	There is a \link{http://coliru.stacked-crooked.com/a/e68e29b6461b083e}{working example on Coliru}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
